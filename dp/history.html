<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>История развития языков программирования</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
</head>
<body>
<div id="content">
<h1>История развития языков программирования</h1>

<p><strong>1837</strong> - Коды операций аналитической машины Чарльз Бэббидж и Ада Лавлэйс.</p>

<p>Первые программы заключались в установке ключевых переключателей на передней панели вычислительного
    устройства. Очевидно, таким способом можно было составить только небольшие программы.</p>

<strong>Появление машинного языка</strong>

<p>С развитием компьютерной техники появился машинный язык, с помощью которого программист мог задавать
    команды, оперируя с ячейками памяти, полностью используя возможности машины. Однако использование
    большинства компьютеров на уровне машинного языка затруднительно, особенно это касается ввода-вывода.
    Поэтому от его использования пришлось отказаться.</p>

<p>«Слова» на машинном языке - <strong>инструкции</strong>, каждая из которых представляет собой одно элементарное
    действие для центрального процессора, такое, например, как считывание информации из ячейки памяти. </p>

<p>Каждая модель процессора имеет свой собственный набор машинных команд, хотя большинство из них совпадает.
    Если Процессор А полностью понимает язык Процессора Б, то говорится, что Процессор А совместим с Процессором
    Б. Процессор Б будет называться не совместимым с Процессором А если А имеет команды, не распознаваемые
    Процессором Б.</p>

<p>На протяжении 60-х годов запросы на разработку программного обеспечения возросли и программы стали очень
    большими. Люди начали понимать, что создание программного обеспечения — гораздо более сложная задача, чем
    они себе представляли. Это привело к тому, что было разработано структурное программирование. С развитием
    структурного программирования следующим достижением были процедуры и функции. К примеру, если есть задача,
    которая выполняется несколько раз, то её можно объявить как функцию или процедуру и в выполнении программы
    просто вызывать её. Общий код программы в данном случае становится меньше. Функции позволяют создавать
    модульные программы.</p>

<p>Следующим достижением было использование структур, благодаря которым перешли к классам. Структуры — это
    составные типы данных, построенные с использованием других типов. Например, структура время. В неё входит:
    часы, минуты, секунды. Программист мог создать структуру время и работать с ней, как с отдельной структурой.
    Класс — это структура, которая имеет свои переменные и функции, которые работают с этими переменными. Это
    было очень большое достижение в области программирования. Теперь программирование можно было разбить на
    классы и тестировать не всю программу, состоящую из 10’000 строк кода, а разбить программу на 100 классов, и
    тестировать каждый класс. Это существенно облегчило написание программного продукта.</p>

<p><strong>Вехи в истории развития языков программирования:</strong></p>

<p><strong>Fortran</strong> (1954-57) - первый язык программирования высокого уровня, имеющий транслятор. Обеспечивал
    представление формул в естественной для математиков форме.
    Название Fortran является сокращением от <strong>FORmula TRANslator</strong> (переводчик формул). </p>

<p><strong>Algol</strong> (1958-1960) - структурное программирование (для выражения алгоритмов и структур данных). Отказ
    от GOTO
    и уход от глобальных переменных.</p>

<p><strong>Pascal</strong> (1970) - Algol для учебных целей. Автор - <a
        href="http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%83%D1%81"
        title="Вирт, Никлаус">Никлаус Вирт</a>. Первая публикация Вирта о языке датирована 1970 годом, представляя язык,
    автор указывал в качестве цели его создания - построение небольшого и эффективного языка, способствующего хорошему
    стилю программирования, использующему структурное программирование и структурированные данные.</p>

<p><strong>C</strong> (1969-73) - системное программирование на языке высокого уровня. Разработан в 1969-73 годах
    сотрудниками Bell Labs Кеном Томпсоном и Деннисом Ритчи как развитие языка B. Первоначально был разработан для
    реализации операционной системы UNIX, но, впоследствии, был перенесён на множество других платформ. Благодаря
    близости по скорости выполнения программ, написанных на C, к языку ассемблера, этот язык получил широкое применение
    при создании системного программного обеспечения и прикладного программного обеспечения для решения широкого круга
    задач. Язык программирования C оказал существенное влияние на развитие индустрии программного обеспечения, а его
    синтаксис стал основой для таких языков программирования как C++, C#, Java и D.</p>

<h2>Объектно-ориентированное программирование (ООП)</h2>

<p><strong>Симула</strong> (1967) - язык программирования общего назначения, разработанный в конце 60-х сотрудниками
    Норвежского Вычислительного Центра (Осло) Кристеном Нюгордом и Оле-Йоханом Далем для моделирования сложных систем.
    Симула считается первым в мире объектно-ориентированным языком, хотя создатель языка Smalltalk Алан Кэй утверждает,
    что изобрёл термин «ООП» и не вдохновлялся Симулой и С++.</p>

<p><strong>SmallTalk</strong> - объектно-ориентированный язык программирования с динамической типизацией,
    разработанный в Xerox PARC Аланом Кэйем, Дэном Ингаллсом, Тедом Кэглером, Адель Голдберг, и другими в 1970-х годах.
    ООП было добавлено в Pascal - Object Pascal, Delphi, и в C - C++, Objective C. </p>

<p>Но с развитием компьютерной техники появился <a
        href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA"
        title="Машинный язык">машинный язык</a>, с помощью которого <a
        href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82"
        title="Программист">программист</a> мог задавать команды, оперируя с ячейками памяти, полностью используя
    возможности машины. Суть этого языка&nbsp;— набор кодов, обязательно понятных процессору, к кому обращаются.
    Части («слова») этого языка называются <a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8"
            title="Код операции"><em>инструкциями</em></a>, каждая из которых представляет собой одно элементарное
    действие для центрального процессора, как, например, считывание информации из ячейки памяти. Если знаешь, можно
    непосредственно управлять процессором. Тогда ещё компьютеры были простыми вычислительными машинами, основная
    задача была считать. Но они развивались, а, понятно дело, использование большинства компьютеров на уровне
    машинного языка затруднительно, особенно это касается ввода-вывода. Поэтому со временем от его использования
    пришлось отказаться.<br>
    Например, для организации чтения блока данных с гибкого диска программист может использовать 16 различных
    команд, каждая из которых требует 13 параметров, таких как номер блока на диске, номер сектора на дорожке и&nbsp;т.&nbsp;п.
    Когда выполнение операции с диском завершается, контроллер возвращает 23 значения, отражающие наличие и типы
    ошибок, которые надо анализировать. Уже одно обращение к процессору громоздко, а анализ ошибок и вовсе
    представляется невообразимым, особенно, если не именно с этим процессором приходится работать. Вообще набор
    команд машинного языка сильно зависит от типа процессора.</p>

<h2>Язык ассемблера </h2>

<p>На протяжении 1950-х годов запросы на разработку программного обеспечения возросли и программы стали очень
    большими. Приходилось писать очень много кода, хотя обеспечение и было весьма простым: по тем временам дизайн
    рабочего стола был проще нынешнего, программы работали с элементарными вещами, а компьютер только ещё начинал
    победно шествовать. Однако программы запутывались всё больше, их структура усложнилась, потому что всё время
    развивалась компьютерная техника. Тогда стали пользоваться специальными программами-<a
            href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80"
            title="Ассемблер">сборщиками программ</a> из маленьких кусочков кодов&nbsp;— ассемблерами. Начался новый
    этап развития.</p>

<p> Теперь, когда была нужна эффективная программа, вместо машинных языков использовались близкие к ним
    машинно-ориентированные <a
            href="http://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0"
            title="Язык ассемблера">языки ассемблера</a>. К таковым относились, например, Autocode, с 1954-го г.&nbsp;—
    IPL (предшественник языка LISP) и, с 1955-го г.&nbsp;— FLOW-MATIC (предшественник языка COBOL). Теперь люди
    стали использовать мнемонические команды взамен машинных команд.</p>

<p> Но даже работа с ассемблером достаточно сложна и требует специальной подготовки. Например, для процессора <a
        href="http://ru.wikipedia.org/wiki/Zilog_Z80" title="Zilog Z80">Zilog Z80</a> машинная команда 00000101
    предписывает процессору уменьшить на единицу свой регистр B. На языке ассемблера это же будет записано как DEC
    B.</p>

<h2>Языки высокого уровня </h2>

<p>Следующий шаг был сделан в 1954 году, когда был создан первый язык высокого уровня&nbsp;— <a
        href="http://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82%D1%80%D0%B0%D0%BD" title="Фортран">Фортран</a>
    <em>FORTRAN - FORmula TRANslator</em>), а за ним и некоторые другие,
    как LISP, ALGOL 58, FACT (ещё один предшественник языка COBOL). <a
            href="http://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%81%D0%BE%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"
            title="Высокоуровневый язык программирования">Языки высокого уровня</a> имитируют естественные языки,
    используя некоторые слова разговорного языка и общепринятые математические символы. Эти языки более удобны для
    человека, с помощью них, можно писать программы до нескольких тысяч строк длиной. Конечно, это достижение было
    очень ценно. Условными словами можно было, как привычно человеку, гораздо более просто выразить сложную
    программную операцию из битов. Однако, легко понимаемый в коротких программах, этот язык становился нечитаемым и
    трудно управляемым, когда дело касалось больших программ. То есть, простоты по-прежнему не хватало. Решение этой
    проблемы пришло после изобретения языков структурного программирования
    <em>structured programming language</em>), таких как
    <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D0%BB" title="Алгол">Алгол</a> (1958), <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8C_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Паскаль (язык программирования)">Паскаль</a> (1970), <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Си (язык программирования)">Си</a> (1972).<br>
    1959-й год&nbsp;— <a href="http://ru.wikipedia.org/wiki/COBOL" title="COBOL">COBOL</a>.<br>
    1962-й год&nbsp;— <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0"
                         title="Симула">Симула</a>.
    С него началась эпоха <em>структурного программирования</em>.</p>

<h2>Появление структурного программирования </h2>

<p>К тому времени люди начали понимать, что создание программного обеспечения&nbsp;— гораздо более сложная задача,
    чем они себе представляли. Это привело к разработке <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Структурное программирование">структурного программирования</a>. С развитием структурного
    программирования следующим достижением были <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Процедура (программирование)">процедуры</a> и <a
            href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Функция (программирование)">функции</a>. То есть, если есть задача, которая выполняется несколько
    раз, то её можно объявить как функцию или как процедуру и в выполнении программы просто вызывать её. Общий код
    программы в данном случае становится меньше. Это способствовало созданию <a
            href="http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Модуль (программирование)">модульных программ</a>.</p>

<p> А следующим достижением было использование <em>структур</em>, благодаря которым перешли к классам. <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Структура (программирование)">Структуры</a>&nbsp;— это составные типы данных, построенные с
    использованием других типов. Например, структура времени: в неё входят: часы, минуты, секунды. Свою очередь и
    часы, и минуты, и секунды&nbsp;— они описаны при помощи других, более простых и более элементарных типов. Вместо
    сложной работы надо множеством типов, из которых каждый может быть со своими ограничениями&nbsp;— и что подходит
    одному типу, запрещено в другом,&nbsp;— вместо того программист бы мог создать структуру «время» и работать с
    ней, как с единым типом, где нету исключений и один формат.</p>

<p> Свою очередь, <a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Класс (программирование)">Класс</a>&nbsp;— это структура, у которой свои переменные и функции,
    которые работают с этими переменными. То есть, это может быть названо особою средою, отличною ото других
    классов. Все классовые члены одного типу. См. подробнее статью.<br>
    Коротко, это достижение в области программирования было очень велико. Теперь программирование можно было разбить
    на классы и тестировать не всю программу, состоящую из 10 000 строк кода, а разбить программу на 100 классов, и
    тестировать каждый класс. Это существенно облегчило написание программного продукта.</p>

<p> Структурное программирование предполагает точно обозначенные управляющие структуры, <a
            href="http://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Блок (программирование)">программные блоки</a>, отсутствие инструкций безусловного перехода
    (GOTO), автономные подпрограммы, поддержка рекурсии и локальных переменных.<br>
    Суть такого подхода заключается в возможности разбиения программы на составляющие элементы.<br>
    Также создавались <em>функциональные</em> (аппликативные) языки (Пример:
    <a href="http://ru.wikipedia.org/wiki/Lisp" title="Lisp">Lisp</a> - <em>LISt Processing</em>, 1958) и
    <em>логические</em> языки (пример: <a href="http://ru.wikipedia.org/wiki/Prolog" title="Prolog">Prolog</a>&nbsp; -
    <em>PROgramming in LOGic</em>, 1972).</p>

<p> Хотя структурное программирование, при его использовании, дало выдающиеся результаты, даже оно оказывалось
    несостоятельным тогда, когда программа достигала определенной длины. Для того чтобы написать более сложную (и
    длинную) программу, нужен был новый подход к программированию.</p>

<h2>
    <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
       title="Объектно-ориентированное программирование">ООП</a></h2>

<p>В итоге в конце 1970-х и начале 1980-х были разработаны принципы <a
        href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
        title="Объектно-ориентированное программирование">объектно-ориентированного программирования</a>. ООП
    сочетает лучшие принципы структурного программирования с новыми мощными концепциями, базовые из которых
    называются <a
            href="http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Инкапсуляция (программирование)">инкапсуляцией</a>, <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Полиморфизм (программирование)">полиморфизмом</a> и <a
            href="http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
            title="Наследование (программирование)">наследованием</a>.</p>

<p> Примерами объектно-ориентированных языков являются <a href="http://ru.wikipedia.org/wiki/Object_Pascal"
                                                          title="Object Pascal">Object Pascal</a>, <a
            href="http://ru.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>, <a
            href="http://ru.wikipedia.org/wiki/Java" title="Java">Java</a>, <a
            href="http://ru.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a> и др.<br>
    ООП позволяет оптимально организовывать программы, разбивая проблему на составные части, и работая с каждой по
    отдельности. Программа на объектно-ориентированном языке, решая некоторую задачу, по сути, описывает часть мира,
    относящуюся к этой задаче.<br>
    ООП возникло в результате развития идеологии <a
            href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Процедурное программирование">процедурного программирования</a>, где данные и подпрограммы
    (процедуры, функции) их обработки формально не связаны. Для дальнейшего развития объектно-ориентированного
    программирования часто большое значение имеют понятия события (так называемое <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Событийно-ориентированное программирование">событийно-ориентированное программирование</a>) и
    компонента (<a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Компонентное программирование">компонентное программирование</a>, КОП).<br>
    Взаимодействие объектов происходит посредством <a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5#.D0.A1.D0.BE.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.B8.D0.B5">сообщений</a>.
    Результатом дальнейшего развития ООП, по-видимому, будет <a
            href="http://ru.wikipedia.org/wiki/%D0%90%D0%B3%D0%B5%D0%BD%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4"
            title="Агентно-ориентированный подход">агентно-ориентированое программирование</a>, где <em>агенты</em>&nbsp;—
    независимые части кода на уровне выполнения. Взаимодействие агентов происходит посредством изменения
    <em>среды</em>, в которой они находятся.</p>

<p> Языковые конструкции, конструктивно не относящиеся непосредственно к объектам, но сопутствующие им для их
    безопасной (<a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9"
            title="Обработка исключений">исключительные ситуации</a>, проверки) и эффективной работы,
    инкапсулируются от них в аспекты (в <a
            href="http://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Аспектно-ориентированное программирование">аспектно-ориентированном программировании</a>). <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"
            title="Субъектно-ориентированное программирование">Субъектно-ориентированное программирование</a>
    расширяет понятие объекта посредством обеспечения более унифицированного и независимого взаимодействия объектов.
    Может являться переходной стадией между ООП и агентным программированием в части самостоятельного их
    взаимодействия.</p>

<p> Первым языком программирования, в котором были предложены принципы объектной ориентированности, была <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0" title="Симула">Симула</a>. В
    момент его появления в <a href="http://ru.wikipedia.org/wiki/1967_%D0%B3%D0%BE%D0%B4" title="1967 год">1967
        году</a> в нём были предложены революционные идеи: объекты, классы, <a
            href="http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4"
            title="Виртуальный метод">виртуальные методы</a> и др., однако это всё не было воспринято современниками
    как нечто грандиозное. Тем не менее, большинство концепций были развиты <a
            href="http://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D0%B9,_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%83%D1%80%D1%82%D0%B8%D1%81"
            title="Кэй, Алан Куртис">Аланом Кэем</a> и <a
            href="http://ru.wikipedia.org/w/index.php?title=%D0%98%D0%BD%D0%B3%D0%B0%D0%BB%D0%BB%D1%81,_%D0%94%D1%8D%D0%BD&action=edit&redlink=1"
            title="Ингаллс, Дэн (страница отсутствует)">Дэном Ингаллсом</a> в языке <a
            href="http://ru.wikipedia.org/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>. Именно он стал первым
    широко распространённым <a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"
            title="Объектно-ориентированный язык программирования">объектно-ориентированным языком
        программирования</a>.</p>

<p> В настоящее время количество прикладных языков программирования (<a
            href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F#.D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D1.8F.D0.B7.D1.8B.D0.BA.D0.BE.D0.B2"
            title="Объектно-ориентированный язык программирования">список языков</a>), реализующих
    объектно-ориентированную парадигму, является наибольшим по отношению к другим парадигмам. В области системного
    программирования до сих пор применяется парадигма процедурного программирования, и общепринятым языком
    программирования является <a
            href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
            title="Си (язык программирования)">Cи</a>. При взаимодействии системного и прикладного уровней
    операционных систем заметное влияние стали оказывать языки объектно-ориентированного программирования. Например,
    одной из наиболее распространённых библиотек мультиплатформенного программирования является
    объектно-ориентированная библиотека <a href="http://ru.wikipedia.org/wiki/Qt" title="Qt">Qt</a>, написанная на
    языке <a href="http://ru.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>.</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p align="center">&nbsp;</p>

<p>&nbsp;</p>

<a href="https://docs.google.com/file/d/1rApWGFnPe3NfCRjNSD8w1-aWlGELjAv7k2VorS6YXmc/edit?usp=sharing">Презентация
    PowerPoint</a>
</div>
</body>
</html>
