<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title>Двудольный граф. Максимальное паросочетание в ДГ</title>
    <link rel="stylesheet" type="text/css" href="../style/style.css">
    <script type="text/javascript" src="../syntax/sh_main.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_pascal.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_cpp.min.js"></script>
    <script type="text/javascript" src="../syntax/sh_python.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
    <div style="float:right;">
        <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
                width="100" height="50">
            <param name="movie" value="../audio/a_smsqulh3n.swf">
            <param name="bgcolor" value="fff">
            <param name="FlashVars" value="src=9094e666f613f513f50301------------ffffff">
            <param name="autoplay" value="false">
            <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff"
                   width="100" height="70" type="application/x-shockwave-flash"
                   pluginspage="http://www.macromedia.com/go/getflashplayer"
                   FlashVars="src=9094e666f613f513f50301------------ffffff"></embed>
        </object>
    </div>
</div>

<div id="content">

<h1>Двудольный граф. Максимальное паросочетание в ДГ.</h1>


<div align="right">
  <p>Гинзбург Наталья Александровна</p>
</div>

<p><strong>ДГ</strong> - граф, вершины которого можно разбить на 2 множества (2  доли), так что рёбра соединяют только вершины из разных долей.</p>
<p><u>Как проверить, двудольный ли граф?</u><br>
  vector&lt;int&gt;  g[MaxN];  // g[1..MaxN,1..MaxN] <br>
  dfs  (deep-first-search)<br>
  dfs( v  )    -- v - вершина<br>
  u[v] = 1; // Посещаем вершину<br>
  // Перебираем соседей </p>
<p>&nbsp;</p>

<pre class="sh_cpp">

void dfs(v){
  u[v] = 1;
  // Перебираем соседей
  for(int i=0;i&lt;g[v].size;i++){
     if(g[v][i])
     if(u[i]){
       dfs(i, 3 - color);
     }
  }
}  
 
for(i=0;i&lt;n;i++)
  if(u[i] == 0)
    dfs(i, 1);   
</pre>

<pre class="sh_cpp">
void dfs(v, color){
  u[v] = color;
  // Перебираем соседей
  for(int i=0;i&lt;g[v].size;i++){
    
  }

</pre>



<p><strong>Паросочетание</strong> - множество ребёр графа, такое что каждая  вершина графа инцидентна не более чем одному ребру графа.</p>
<p>  <strong>Размер паросочетания</strong> - мощность множества ребёр этого  паросочетания.</p>
<p>  <strong>Максимальное паросочетание</strong> - паросочетание максимального  размера.</p>
<p>Жадный алгоритм не работает.</p>
<p><strong>Цепь в ДГ</strong> - простой путь.</p>
<p><strong>Чередующаяся цепь</strong> относительно паросочетания $М$ - цепь, в которой чередуются рёбра из $M$ и из $не М$.</p>
<p><strong>Дополняющая цепь</strong> - чередующаяся цепь относительно паросочетания $M$, в которой оба крайних ребра тоже не принадлежат $M$.</p>
<p><strong>Теорема Бержа </strong></p>
<p>Паросочетание $M$ максимально $&lt;=&gt;$ не сущ. дополняющих цепей относительно $M$.</p>
<p>$=&gt;$ Если $\exists$ дополняющая цепь, то можно увеличить вдоль неё, значит, $M$ не максимальна.</p>
<p>$&lt;=$ Пусть $М$ - паросоч. отн. которой не $\exists$ доп. цепей, $M'&gt;M$.</p>
<p>$\angle$ $M \bigtriangleup M'$ - ребра, которые лежат либо в M, либо в M'.</p>
<p>$\exists$ путь: ребер в $M'$</p>
<p><strong>Алгоритм Куна</strong> </p>
<p>Общий вид: </p>
<ul>
  <li>Есть текущее паросочетание, сначала нулевого размера, потом наращиваем. </li>
  <li>Находим дополняющую цепь из какой-то вершины.</li>
  <li>Увеличиваем паросочетание, пока есть дополняющие цепи.</li>
</ul>

<pre class="sh_pascal">
var n : integer; { Количество вершин }

function dfs( v : integer ):integer; 
var i, ret : integer;
begin
  ret := 0; { Изначально считаем, что возвращаем ноль }
  u[v] := 1;
  if f(v) then 
    ret := 1;
  else   
    for i:=1 to n do 
      if g[v][i] and (u[i] = 0) then
        ret := ret or dfs() 
  dfs := ret;      
end;
</pre>

Поиск паросочетания:
<pre class="sh_cpp">
// Первая доля, Вторая доля - рёбра только из одно доли в другую 
g[1..n1][1..n2] // Граф g[i][j]=1 если есть ребро из i в j
u[1..n1] // Пометки, что посещена 
// для каждой вершины второй доли будем указывать, с какой вершиной из первой доли она связана
to[1..n2] 

// Возвращает 1 если мы нашли дополняющую цепь и 0 - если не нашли
int match(int v1){  // v1 - вершина из первой доли
  int i, ret;  // ret - результат
  if(u[v] == 1)
    return 0;
  u[v] = 1; // Отмечаем, что в вершине v мы были  
  for(int i2=0; i2 > n2; i2++)
  if (g[v1][i2] && (to[i2]==1 || match(to[i2])) {
    to[i2] = v1;    
    return 1;
  }  
  return 0;    
}
</pre>

<p>Мы умеем запускать из какой-то вершины дополняющую цепь</p>
<p>Сколько раз надо запустить match?</p>

<p>Достаточно запустить $n$ раз поиск доподняющей цепи, по 1 разу для каждой вершины первой доли.</p>

<pre class="sh_cpp">
int res = 0;
for(int i1=0; i1&lt;n1; i++){
  memset(u, 0, sizeof(u));
  res += match(i);
}
// res - размер паросочетания
</pre>

<p>Почему этого достаточно: На каждом шаге строится максимальное паросочетание на подграфе из $i+1$ первых вершин 1-ой доли и всех вершин второй.</p>

<h3>Классическая задача</h3>
<p>Одна доля - мальчики. Другая доля девочки.</p>
<h3>Шахматная доска</h3>
<p>Дана шахматная доска $m$ на $n$ с некоторыми вырезанными  клетками, надо расставить максимальное количество ладей, так чтобы они друг друга  не били.</p>
<p>&nbsp;</p>
</div>
</body>

</html>
